<!-- Carousel Wrapper -->
<div class='relative' data-tcarousel data-section-id='{{ section.id }}'>
  <!-- Viewport -->
  <div class='overflow-hidden'>
    <!-- Track -->
    <div
      class='flex transition-transform duration-500 ease-in-out will-change-transform cursor-grab active:cursor-grabbing select-none'
      data-track
    >
      {% for block in section.blocks %}
        <div class='testimonial-card w-full md:w-1/2 flex-shrink-0 px-4' data-slide {{ block.shopify_attributes }}>
          <div class='bg-darkest rounded-lg p-6 shadow-lg h-full'>
            <!-- your existing testimonial markup here -->
            <h3 class='text-xl font-semibold'>{{ block.settings.reviewer_name }}</h3>
            <p class='text-md font-semibold italic mb-2'>{{ block.settings.reviewer_occupation }}</p>
            <div class='flex items-center mb-4'>
              {% assign stars = block.settings.stars | plus: 0 %}
              {% for i in (1..5) %}
                {% if i <= stars %}
                  <svg class='h-5 w-5 text-primary fill-current' viewBox='0 0 20 20'>
                    <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.286 3.967h4.17c.969 0 1.371 1.24.588 1.81l-3.37 2.449 1.286 3.966c.3.921-.755 1.688-1.54 1.118L10 13.347l-3.371 2.449c-.784.57-1.838-.197-1.539-1.118l1.285-3.966-3.37-2.449c-.784-.57-.381-1.81.588-1.81h4.17l1.286-3.967z"/>
                  </svg>
                {% else %}
                  <svg class='h-5 w-5 text-gray-500 fill-current' viewBox='0 0 20 20'>
                    <path d="M9.049 2.927c.3-.921 1.603-.921 1.902 0l1.286 3.967h4.17c.969 0 1.371 1.24.588 1.81l-3.37 2.449 1.286 3.966c.3.921-.755 1.688-1.54 1.118L10 13.347l-3.371 2.449c-.784.57-1.838-.197-1.539-1.118l1.285-3.966-3.37-2.449c-.784-.57-.381-1.81.588-1.81h4.17l1.286-3.967z"/>
                  </svg>
                {% endif %}
              {% endfor %}
            </div>
            <div class='text-light/80'>{{ block.settings.content }}</div>
          </div>
        </div>
      {% endfor %}
    </div>
  </div>

  <!-- Prev/Next -->
  <button
    type='button'
    data-prev
    class='absolute top-1/2 left-0 -translate-y-1/2 bg-darkest p-2 rounded-full hover:bg-primary hover:text-dark transition z-10'
  >
    <span class='sr-only'>Previous</span>
    <svg
      aria-hidden='true'
      width='20'
      height='20'
      viewBox='0 0 24 24'
      fill='none'
      stroke='currentColor'
      stroke-width='2'
    >
      <path d="M15 18l-6-6 6-6" />
    </svg>
  </button>

  <button
    type='button'
    data-next
    class='absolute top-1/2 right-0 -translate-y-1/2 bg-darkest p-2 rounded-full hover:bg-primary hover:text-dark transition z-10'
  >
    <span class='sr-only'>Next</span>
    <svg
      aria-hidden='true'
      width='20'
      height='20'
      viewBox='0 0 24 24'
      fill='none'
      stroke='currentColor'
      stroke-width='2'
    >
      <path d="M9 6l6 6-6 6" />
    </svg>
  </button>

  <!-- Dots -->
  <div class='flex justify-center gap-2 mt-6 flex-wrap' data-dots aria-label='Testimonials pagination'></div>
</div>

<script>
  document.addEventListener('DOMContentLoaded', () => {
    document.querySelectorAll('[data-tcarousel]').forEach((root) => {
      const track = root.querySelector('[data-track]');
      const viewport = track?.parentElement;
      const prevBtn = root.querySelector('[data-prev]');
      const nextBtn = root.querySelector('[data-next]');
      const dotsWrap = root.querySelector('[data-dots]');
      if (!track || !viewport) return;

      const prefersReducedMotion = window.matchMedia('(prefers-reduced-motion: reduce)').matches;

      // Original slides (before cloning)
      let slides = Array.from(track.querySelectorAll('[data-slide]'));
      const originalCount = slides.length;

      if (originalCount <= 1) return;

      // Responsive count
      const perView = () => (window.matchMedia('(min-width: 768px)').matches ? 2 : 1);

      // One step equals "one card" (not a full page)
      const stepPx = () => viewport.getBoundingClientRect().width / perView();

      // We clone N slides on each side, where N = perView()
      const cloneCount = () => perView();

      // State
      let index = 0; // index within ORIGINAL slides (0..originalCount-1)
      let internalIndex = 0; // index within TRACK (including clones)
      let isDragging = false;
      let startX = 0;
      let startTranslate = 0;
      let currentTranslate = 0;

      function setTransition(on) {
        track.style.transition = on && !prefersReducedMotion ? 'transform 500ms cubic-bezier(.25,.46,.45,.94)' : 'none';
      }

      function applyTranslate(px) {
        track.style.transform = `translateX(${px}px)`;
      }

      // Build dots
      function buildDots() {
        if (!dotsWrap) return;
        dotsWrap.innerHTML = '';
        for (let i = 0; i < originalCount; i++) {
          const b = document.createElement('button');
          b.type = 'button';
          b.setAttribute('aria-label', `Go to testimonial ${i + 1}`);
          b.className = 'tcarousel-dot' + (i === index ? ' is-active' : '');
          b.dataset.dotIndex = String(i);
          b.addEventListener('click', () => goTo(i, true));
          dotsWrap.appendChild(b);
        }
      }

      function setActiveDot() {
        if (!dotsWrap) return;
        dotsWrap.querySelectorAll('[data-dot-index]').forEach((el) => {
          const i = Number(el.dataset.dotIndex);
          el.classList.toggle('is-active', i === index);
        });
      }

      // Clone helpers
      function clearClones() {
        track.querySelectorAll('[data-clone="true"]').forEach((n) => n.remove());
      }

      function makeClone(node) {
        const c = node.cloneNode(true);
        c.setAttribute('data-clone', 'true');
        // avoid duplicate editor attrs in clones (safe to strip)
        c.removeAttribute('data-shopify-editor-block-id');
        return c;
      }

      function setupClones() {
        clearClones();

        slides = Array.from(track.querySelectorAll('[data-slide]'));
        const n = cloneCount();

        const head = slides.slice(0, n).map(makeClone);
        const tail = slides.slice(-n).map(makeClone);

        // prepend tail clones, append head clones
        tail.reverse().forEach((c) => track.insertBefore(c, track.firstChild));
        head.forEach((c) => track.appendChild(c));

        // update slides list INCLUDING clones
        slides = Array.from(track.children);

        // internalIndex points to the first "real" slide + current index
        internalIndex = n + index;

        // jump (no animation) to correct position
        setTransition(false);
        currentTranslate = -(internalIndex * stepPx());
        applyTranslate(currentTranslate);
        setActiveDot();
      }

      function normalizeIndex(i) {
        // wrap 0..originalCount-1
        const m = ((i % originalCount) + originalCount) % originalCount;
        return m;
      }

      function goTo(newIndex, smooth) {
        index = normalizeIndex(newIndex);
        const n = cloneCount();
        internalIndex = n + index;

        setTransition(!!smooth);
        currentTranslate = -(internalIndex * stepPx());
        applyTranslate(currentTranslate);
        setActiveDot();
      }

      function next() {
        index = normalizeIndex(index + 1);
        internalIndex += 1;
        setTransition(true);
        currentTranslate = -(internalIndex * stepPx());
        applyTranslate(currentTranslate);
        setActiveDot();
      }

      function prev() {
        index = normalizeIndex(index - 1);
        internalIndex -= 1;
        setTransition(true);
        currentTranslate = -(internalIndex * stepPx());
        applyTranslate(currentTranslate);
        setActiveDot();
      }

      // After transition, if weâ€™re sitting on a clone area, snap back to the real slide
      function snapIfOnClone() {
        const n = cloneCount();
        const min = n; // first real
        const max = n + originalCount - 1; // last real

        if (internalIndex < min) {
          internalIndex = n + index;
          setTransition(false);
          currentTranslate = -(internalIndex * stepPx());
          applyTranslate(currentTranslate);
        }

        if (internalIndex > max) {
          internalIndex = n + index;
          setTransition(false);
          currentTranslate = -(internalIndex * stepPx());
          applyTranslate(currentTranslate);
        }
      }

      track.addEventListener('transitionend', snapIfOnClone);

      // Buttons
      nextBtn?.addEventListener('click', next);
      prevBtn?.addEventListener('click', prev);

      // Drag/swipe
      function onDragStart(clientX) {
        isDragging = true;
        startX = clientX;
        startTranslate = currentTranslate;
        setTransition(false);
      }

      function onDragMove(clientX) {
        if (!isDragging) return;
        const dx = clientX - startX;
        applyTranslate(startTranslate + dx);
      }

      function onDragEnd(clientX) {
        if (!isDragging) return;
        isDragging = false;

        const dx = clientX - startX;
        const threshold = stepPx() * 0.2;

        if (dx < -threshold) next();
        else if (dx > threshold) prev();
        else {
          // snap back
          setTransition(true);
          applyTranslate(currentTranslate);
        }
      }

      track.addEventListener('touchstart', (e) => onDragStart(e.touches[0].clientX), { passive: true });
      track.addEventListener('touchmove', (e) => onDragMove(e.touches[0].clientX), { passive: true });
      track.addEventListener('touchend', (e) => {
        const endX = e.changedTouches && e.changedTouches[0] ? e.changedTouches[0].clientX : startX;
        onDragEnd(endX);
      });

      track.addEventListener('mousedown', (e) => {
        e.preventDefault();
        onDragStart(e.clientX);
      });
      window.addEventListener('mousemove', (e) => onDragMove(e.clientX));
      window.addEventListener('mouseup', (e) => onDragEnd(e.clientX));

      // Rebuild on resize (breakpoint changes affect perView and cloneCount)
      let resizeTimer = null;
      window.addEventListener('resize', () => {
        window.clearTimeout(resizeTimer);
        resizeTimer = window.setTimeout(() => {
          setupClones();
        }, 50);
      });

      // Init
      buildDots();
      setupClones();
    });
  });
</script>
